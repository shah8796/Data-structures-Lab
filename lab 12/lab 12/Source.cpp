#include <iostream>
#include <list>
#include <vector>
using namespace std;
class Graph
{
    int v;          // No. of vertices
    list<int>* adj; // adjacency lists
public:
    Graph(int n);                    // Constructor
    void TakeInput(int n, int w);    // to take input from the user in this sequence:
                                     // number of nodes,
                                     // what are the neighbors of vertex 0, what are the neighbors of vertex 1, ... so on.
    void ExploreFunction(int start); // print the paths from start to every other vertex as generated by the dfs method.One path per line.
    void ExploreFunctionRec(int v, bool*& visited, vector<int>& vec);
};

Graph::Graph(int V)
{
    this->v = V;
    adj = new list<int>[V];
}

void Graph::TakeInput(int u, int v)
{
    adj[u].push_back(v); // Add v to u’s list.
}

void Graph::ExploreFunction(int v)
{
    bool* visited;
    visited = new bool[v];
    vector<int> vec;
    ExploreFunctionRec(v, visited, vec);
}

void Graph::ExploreFunctionRec(int v, bool*& visited, vector<int>& vec)
{
    visited[v] = true;
    vec.push_back(v);
    if (vec.size() != 1)
    {
        for (auto& itr : vec)
        {
            cout << itr << " ";
        }
        cout << endl;
    }
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            ExploreFunctionRec(*i, visited, vec);
}

int main()
{
    Graph g(4); // Total 5 vertices in graph

    g.TakeInput(0, 1);
    g.TakeInput(0, 2);
    g.TakeInput(1, 2);
    g.TakeInput(2, 0);
    g.TakeInput(2, 3);
    g.TakeInput(3, 3);
    cout << "Following is Depth First Traversal\n ";
    g.ExploreFunction(2);
    // Sample output of explore function for starting from vertex 2.
    // 2 0
    // 2 0 1
    // 2 0 1 3
    //***
    // Sample output of explore function for starting from vertex 1.
    // 1 2
    // 1 2 0
    // 1 2 0 3
    return 0;
}